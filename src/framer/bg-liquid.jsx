// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 6d1ac80c6e7bce05 "Projeto Chacal", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * variant?: 'Default' | 'Mobile' | 'Stop Play' // Variant
 * playing?: boolean // Playing
 * startTime?: number // Start Time
}} Props

 */
import { routes } from "./chunks/chunk-XLH7UDAO.js";

// virtual:bg-liquid
import { Fragment as Fragment2 } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/yDj7wWMyiDppD8RcoPSb/FKDW7WjxmmXbaQHQ5CBY/KhMFb9C09.js
import { jsx as _jsx2 } from "react/jsx-runtime";
import {
	addFonts,
	addPropertyControls as addPropertyControls2,
	ComponentViewportProvider,
	ControlType as ControlType5,
	cx,
	getFonts,
	useComponentViewport,
	useLocaleInfo,
	useVariantState,
	withCSS,
} from "unframer";
import { LayoutGroup, motion, MotionConfigContext } from "unframer";
import * as React3 from "react";

// /:https://framerusercontent.com/modules/lRDHiNWNVWmE0lqtoVHP/7qT0r3So12155VV5Jq5x/Video.js
import { jsx as _jsx } from "react/jsx-runtime";
import {
	addPropertyControls,
	ControlType as ControlType4,
	useIsInCurrentNavigationTarget as useIsInCurrentNavigationTarget2,
	RenderTarget as RenderTarget3,
} from "unframer";
import { isMotionValue as isMotionValue2, useInView } from "unframer";

// /:https://framerusercontent.com/modules/VTUDdizacRHpwbkOamr7/AykinQJbgwl92LvMGZwu/constants.js
import { ControlType } from "unframer";
var containerStyles = {
	position: "relative",
	width: "100%",
	height: "100%",
	display: "flex",
	justifyContent: "center",
	alignItems: "center",
};
var emptyStateStyle = {
	...containerStyles,
	borderRadius: 6,
	background: "rgba(136, 85, 255, 0.3)",
	color: "#85F",
	border: "1px dashed #85F",
	flexDirection: "column",
};
var defaultEvents = {
	onClick: {
		type: ControlType.EventHandler,
	},
	onMouseEnter: {
		type: ControlType.EventHandler,
	},
	onMouseLeave: {
		type: ControlType.EventHandler,
	},
};
var fontSizeOptions = {
	type: ControlType.Number,
	title: "Font Size",
	min: 2,
	max: 200,
	step: 1,
	displayStepper: true,
};
var fontControls = {
	font: {
		type: ControlType.Boolean,
		title: "Font",
		defaultValue: false,
		disabledTitle: "Default",
		enabledTitle: "Custom",
	},
	fontFamily: {
		type: ControlType.String,
		title: "Family",
		placeholder: "Inter",
		hidden: ({ font }) => !font,
	},
	fontWeight: {
		type: ControlType.Enum,
		title: "Weight",
		options: [100, 200, 300, 400, 500, 600, 700, 800, 900],
		optionTitles: [
			"Thin",
			"Extra-light",
			"Light",
			"Regular",
			"Medium",
			"Semi-bold",
			"Bold",
			"Extra-bold",
			"Black",
		],
		hidden: ({ font }) => !font,
	},
};

// /:https://framerusercontent.com/modules/D4TWeLfcxT6Tysr2BlYg/iZjmqdxVx1EOiM3k1FaW/useOnNavigationTargetChange.js
import { useIsInCurrentNavigationTarget } from "unframer";
import { useEffect } from "react";
function useOnEnter(onEnter, enabled) {
	return useOnSpecificTargetChange(true, onEnter, enabled);
}
function useOnExit(onExit, enabled) {
	return useOnSpecificTargetChange(false, onExit, enabled);
}
function useOnSpecificTargetChange(goal, callback, enabled = true) {
	const isInTarget = useIsInCurrentNavigationTarget();
	useEffect(() => {
		if (enabled && isInTarget === goal) callback();
	}, [isInTarget]);
}

// /:https://framerusercontent.com/modules/ExNgrA7EJTKUPpH6vIlN/eiOrSJ2Ab5M9jPCvVwUz/useConstant.js
import { useRef } from "react";

// /:https://framerusercontent.com/modules/D2Lz5CmnNVPZFFiZXalt/QaCzPbriZBfXWZIIycFI/colorFromToken.js
import { Color } from "unframer";

// /:https://framerusercontent.com/modules/3mKFSGQqKHV82uOV1eBc/5fbRLvOpxZC0JOXugvwm/isMotionValue.js
import { MotionValue } from "unframer";

// /:https://framerusercontent.com/modules/xDiQsqBGXzmMsv7AlEVy/uhunpMiNsbXxzjlXsg1y/useUniqueClassName.js
import * as React from "react";

// /:https://framerusercontent.com/modules/ETACN5BJyFTSo0VVDJfu/NHRqowOiXkF9UwOzczF7/variantUtils.js
import { ControlType as ControlType2 } from "unframer";

// /:https://framerusercontent.com/modules/eMBrwoqQK7h6mEeGQUH8/GuplvPJVjmxpk9zqOTcb/isBrowser.js
import { useMemo } from "react";
var __unframerNavigator = typeof window !== "undefined" ? navigator : void 0;
var isBrowserSafari = () => {
	if (typeof __unframerNavigator !== `undefined`) {
		const userAgent = __unframerNavigator.userAgent.toLowerCase();
		const isSafari =
			(userAgent.indexOf("safari") > -1 ||
				userAgent.indexOf("framermobile") > -1 ||
				userAgent.indexOf("framerx") > -1) &&
			userAgent.indexOf("chrome") < 0;
		return isSafari;
	} else return false;
};
var useIsBrowserSafari = () => useMemo(() => isBrowserSafari(), []);

// /:https://framerusercontent.com/modules/v9AWX2URmiYsHf7GbctE/XxKAZ9KlhWqf5x1JMyyF/useOnChange.js
import { useEffect as useEffect3 } from "react";

// /:https://framerusercontent.com/modules/kNDwabfjDEb3vUxkQlZS/fSIr3AOAYbGlfSPgXpYu/useAutoMotionValue.js
import { useCallback, useEffect as useEffect4, useRef as useRef2 } from "react";
import { motionValue, animate, RenderTarget } from "unframer";

// /:https://framerusercontent.com/modules/cuQH4dmpDnV8YK1mSgQX/KqRXqunFjE6ufhpc7ZRu/useFontControls.js
import { fontStore } from "unframer";
import { useEffect as useEffect5 } from "react";

// /:https://framerusercontent.com/modules/afBE9Yx1W6bY5q32qPxe/m3q7puE2tbo1S2C0s0CT/useRenderTarget.js
import { useMemo as useMemo2 } from "react";
import { RenderTarget as RenderTarget2 } from "unframer";
function useRenderTarget() {
	const currentRenderTarget = useMemo2(() => RenderTarget2.current(), []);
	return currentRenderTarget;
}
function useIsOnCanvas() {
	const onCanvas = useMemo2(
		() => RenderTarget2.current() === RenderTarget2.canvas,
		[],
	);
	return onCanvas;
}

// /:https://framerusercontent.com/modules/zGkoP8tPDCkoBzMdt5uq/0zFSjxIYliHxrQQnryFX/useControlledState.js
import * as React2 from "react";

// /:https://framerusercontent.com/modules/5SM58HxZHxjjv7aLMOgQ/WXz9i6mVki0bBCrKdqB3/propUtils.js
import { useMemo as useMemo3 } from "react";
import { ControlType as ControlType3 } from "unframer";
function useRadius(props) {
	const {
		borderRadius,
		isMixedBorderRadius,
		topLeftRadius,
		topRightRadius,
		bottomRightRadius,
		bottomLeftRadius,
	} = props;
	const radiusValue = useMemo3(
		() =>
			isMixedBorderRadius
				? `${topLeftRadius}px ${topRightRadius}px ${bottomRightRadius}px ${bottomLeftRadius}px`
				: `${borderRadius}px`,
		[
			borderRadius,
			isMixedBorderRadius,
			topLeftRadius,
			topRightRadius,
			bottomRightRadius,
			bottomLeftRadius,
		],
	);
	return radiusValue;
}
var borderRadiusControl = {
	borderRadius: {
		title: "Radius",
		type: ControlType3.FusedNumber,
		toggleKey: "isMixedBorderRadius",
		toggleTitles: ["Radius", "Radius per corner"],
		valueKeys: [
			"topLeftRadius",
			"topRightRadius",
			"bottomRightRadius",
			"bottomLeftRadius",
		],
		valueLabels: ["TL", "TR", "BR", "BL"],
		min: 0,
	},
};
var paddingControl = {
	padding: {
		type: ControlType3.FusedNumber,
		toggleKey: "paddingPerSide",
		toggleTitles: ["Padding", "Padding per side"],
		valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
		valueLabels: ["T", "R", "B", "L"],
		min: 0,
		title: "Padding",
	},
};

// /:https://framerusercontent.com/modules/lRDHiNWNVWmE0lqtoVHP/7qT0r3So12155VV5Jq5x/Video.js
import {
	memo,
	useCallback as useCallback2,
	useEffect as useEffect7,
	useMemo as useMemo4,
	useRef as useRef3,
	useState as useState3,
} from "react";
var ObjectFitType;
(function (ObjectFitType2) {
	ObjectFitType2["Fill"] = "fill";
	ObjectFitType2["Contain"] = "contain";
	ObjectFitType2["Cover"] = "cover";
	ObjectFitType2["None"] = "none";
	ObjectFitType2["ScaleDown"] = "scale-down";
})(ObjectFitType || (ObjectFitType = {}));
var SrcType;
(function (SrcType2) {
	SrcType2["Video"] = "Upload";
	SrcType2["Url"] = "URL";
})(SrcType || (SrcType = {}));
var defaultVideo =
	"https://framerusercontent.com/assets/MLWPbW1dUQawJLhhun3dBwpgJak.mp4";
function getProps(props) {
	const {
		width,
		height,
		topLeft,
		topRight,
		bottomRight,
		bottomLeft,
		id,
		children,
		...rest
	} = props;
	return rest;
}
function Video(props) {
	const newProps = getProps(props);
	return <VideoMemo {...newProps} />;
}
function usePlaybackControls(videoRef) {
	const isInCurrentNavigationTarget = useIsInCurrentNavigationTarget2();
	const requestingPlay = useRef3(false);
	const isPlayingRef = useRef3(false);
	const setProgress = useCallback2((rawProgress) => {
		if (!videoRef.current) return;
		const newProgress =
			(rawProgress === 1 ? 0.999 : rawProgress) * videoRef.current.duration;
		const isAlreadySet =
			Math.abs(videoRef.current.currentTime - newProgress) < 0.1;
		if (videoRef.current.duration > 0 && !isAlreadySet) {
			videoRef.current.currentTime = newProgress;
		}
	}, []);
	const play = useCallback2(() => {
		const video = videoRef.current;
		if (!video) return;
		video.preload = "auto";
		const isPlaying =
			video.currentTime > 0 &&
			video.onplaying &&
			!video.paused &&
			!video.ended &&
			video.readyState >= video.HAVE_CURRENT_DATA;
		if (
			!isPlaying &&
			video &&
			!requestingPlay.current &&
			isInCurrentNavigationTarget
		) {
			requestingPlay.current = true;
			isPlayingRef.current = true;
			video
				.play()
				.catch((e) => {})
				.finally(() => (requestingPlay.current = false));
		}
	}, []);
	const pause = useCallback2(() => {
		if (!videoRef.current || requestingPlay.current) return;
		videoRef.current.pause();
		isPlayingRef.current = false;
	}, []);
	return {
		play,
		pause,
		setProgress,
		isPlaying: isPlayingRef,
	};
}
function useAutoplayBehavior({
	playingProp,
	muted,
	loop,
	playsinline,
	controls,
}) {
	const [initialPlayingProp] = useState3(() => playingProp);
	const [hasPlayingPropChanged, setHasPlayingPropChanged] = useState3(false);
	if (playingProp !== initialPlayingProp && !hasPlayingPropChanged) {
		setHasPlayingPropChanged(true);
	}
	const behavesAsGif =
		// passing `playing === true` on mount indicates that the video should
		// autoplay, like a GIF
		initialPlayingProp &&
		muted &&
		loop &&
		playsinline &&
		!controls &&
		// Some users of the <Video> component use it by wrapping it with
		// another smart component and adding their own controls on top. (The
		// controls use transitions to control the video: e.g., when clicking
		// the play button, the smart component will transition to a state with
		// <Video playing={true} />.) In this case, we don't want the video to
		// behave as a gif, as it will be weird if the video suddenly started
		// acting as such (and auto-pausing when leaving the viewport) as soon
		// as the site visitor mutes it and clicks “Play”.
		!hasPlayingPropChanged;
	let autoplay;
	if (behavesAsGif) autoplay = "on-viewport";
	else if (initialPlayingProp) autoplay = "on-mount";
	else autoplay = "no-autoplay";
	return autoplay;
}
var VideoMemo = /* @__PURE__ */ memo(function VideoInner(props) {
	const {
		// default props
		srcType = "URL",
		srcUrl,
		srcFile = "",
		posterEnabled = false,
		controls = false,
		playing = true,
		loop = true,
		muted = true,
		playsinline = true,
		restartOnEnter = false,
		objectFit = "cover",
		backgroundColor = "rgba(0,0,0,0)",
		radius = 0,
		volume = 25,
		startTime: startTimeProp = 0,
		poster,
		playing: playingProp,
		progress,
		onSeeked,
		onPause,
		onPlay,
		onEnd,
		onClick,
		onMouseEnter,
		onMouseLeave,
		onMouseDown,
		onMouseUp,
	} = props;
	const videoRef = useRef3();
	const isSafari = useIsBrowserSafari();
	const wasPausedOnLeave = useRef3(null);
	const wasEndedOnLeave = useRef3(null);
	const isOnCanvas = useIsOnCanvas();
	const renderTarget = useRenderTarget();
	const isStaticRenderer = isOnCanvas || renderTarget === RenderTarget3.export;
	const borderRadius = useRadius(props);
	const autoplayBehavior = isStaticRenderer
		? "no-autoplay"
		: useAutoplayBehavior({
				playingProp,
				muted,
				loop,
				playsinline,
				controls,
			});
	const isInViewport = isStaticRenderer ? true : useInView(videoRef);
	const isCloseToViewport = isStaticRenderer
		? false
		: useInView(videoRef, {
				margin: "10%",
				once: true,
			});
	const startTime = startTimeProp === 100 ? 99.9 : startTimeProp;
	const { play, pause, setProgress, isPlaying } = usePlaybackControls(videoRef);
	useEffect7(() => {
		if (isStaticRenderer) return;
		if (autoplayBehavior === "on-viewport") return;
		if (playingProp) play();
		else pause();
	}, [autoplayBehavior, playingProp]);
	useEffect7(() => {
		if (isStaticRenderer) return;
		if (isInViewport && playingProp && autoplayBehavior !== "no-autoplay")
			play();
		if (autoplayBehavior !== "on-viewport") return;
		pause();
	}, [autoplayBehavior, isInViewport, playingProp]);
	useEffect7(() => {
		if (
			!isOnCanvas ||
			poster ||
			posterEnabled ||
			startTime ||
			!videoRef.current
		)
			return;
		videoRef.current.currentTime = 0.01;
	}, [posterEnabled, poster, startTime]);
	const isMountedAndReadyForProgressChanges = useRef3(false);
	useEffect7(() => {
		if (!isMountedAndReadyForProgressChanges.current) {
			isMountedAndReadyForProgressChanges.current = true;
			return;
		}
		const rawProgressValue = isMotionValue2(progress)
			? progress.get()
			: (progress ?? 0) * 0.01;
		setProgress(
			// When the progress value exists (e.g. <Video startTime={10}
			// progress={50} />), we respect the `progress` value over
			// `startTime`, even if `startTime` changes. That’s because
			// `startTime` == start == changing it shouldn’t affect the current
			// progress
			(rawProgressValue ?? 0) ||
				// Then why fall back to `startTime` when `progress` doesn’t exist,
				// you might ask? Now, that’s for
				// - canvas UX: we want the video progress to change when the user
				//   is scrobbling the “Start Time” in component settings.
				// - backwards compatibility: maybe some users *are* scrobbling
				//   using `startTime` instead of `progress`? We don’t know, and it
				//   always supported it, so let’s not break it
				(startTime ?? 0) / 100,
		);
	}, [startTime, srcFile, srcUrl, progress]);
	useEffect7(() => {
		if (!isMotionValue2(progress)) return;
		return progress.on("change", (value) => setProgress(value));
	}, [progress]);
	useOnEnter(() => {
		if (wasPausedOnLeave.current === null) return;
		if (videoRef.current) {
			if ((!wasEndedOnLeave && loop) || !wasPausedOnLeave.current) play();
		}
	});
	useOnExit(() => {
		if (videoRef.current) {
			wasEndedOnLeave.current = videoRef.current.ended;
			wasPausedOnLeave.current = videoRef.current.paused;
			pause();
		}
	});
	const src = useMemo4(() => {
		let fragment = "";
		if (srcType === "URL") return srcUrl + fragment;
		if (srcType === "Upload") return srcFile + fragment;
	}, [srcType, srcFile, srcUrl, startTime]);
	useEffect7(() => {
		if (isSafari && videoRef.current && autoplayBehavior === "on-mount") {
			setTimeout(() => play(), 50);
		}
	}, []);
	useEffect7(() => {
		if (videoRef.current && !muted)
			videoRef.current.volume = (volume ?? 0) / 100;
	}, [volume]);
	const handleReady = () => {
		const video = videoRef.current;
		if (!video) return;
		if (video.currentTime < 0.3 && startTime > 0)
			setProgress((startTime ?? 0) * 0.01);
		if (
			// when the component updates (e.g. only srcFile/url changes), and the video was already playing, keep playing
			isPlaying.current ||
			autoplayBehavior === "on-mount" ||
			(playingProp && autoplayBehavior === "on-viewport" && isInViewport)
		)
			play();
	};
	return (
		<video
			onClick={onClick}
			onMouseEnter={onMouseEnter}
			onMouseLeave={onMouseLeave}
			onMouseDown={onMouseDown}
			onMouseUp={onMouseUp}
			src={src}
			loop={loop}
			ref={videoRef}
			onSeeked={(e) => onSeeked?.(e)}
			onPause={(e) => onPause?.(e)}
			onPlay={(e) => onPlay?.(e)}
			onEnded={(e) => onEnd?.(e)}
			autoPlay={
				isPlaying.current ||
				autoplayBehavior === "on-mount" ||
				(playingProp && autoplayBehavior === "on-viewport" && isInViewport)
			}
			preload={
				isPlaying.current
					? "auto"
					: isStaticRenderer && !poster
						? "metadata"
						: autoplayBehavior !== "on-mount" && !isCloseToViewport
							? "none"
							: // `autoplay` overrides this too
								"metadata"
			}
			poster={
				posterEnabled && !srcFile && srcUrl === defaultVideo
					? "https://framerusercontent.com/images/5ILRvlYXf72kHSVHqpa3snGzjU.jpg"
					: posterEnabled && poster
						? poster
						: void 0
			}
			onLoadedData={handleReady}
			controls={controls}
			muted={isStaticRenderer ? true : muted}
			playsInline={playsinline}
			style={{
				cursor: !!onClick ? "pointer" : "auto",
				width: "100%",
				height: "100%",
				borderRadius,
				display: "block",
				objectFit,
				backgroundColor,
				objectPosition: "50% 50%",
			}}
		/>
	);
});
Video.displayName = "Video";
function capitalizeFirstLetter(value) {
	return value.charAt(0).toUpperCase() + value.slice(1);
}
function titleCase(value) {
	const groups = value.match(/[A-Z]{2,}|[A-Z][a-z]+|[a-z]+|[A-Z]|\d+/gu) || [];
	return groups.map(capitalizeFirstLetter).join(" ");
}
var objectFitOptions = ["cover", "fill", "contain", "scale-down", "none"];
addPropertyControls(Video, {
	srcType: {
		type: ControlType4.Enum,
		displaySegmentedControl: true,
		title: "Source",
		options: ["URL", "Upload"],
	},
	srcUrl: {
		type: ControlType4.String,
		title: "URL",
		defaultValue:
			"https://framerusercontent.com/assets/MLWPbW1dUQawJLhhun3dBwpgJak.mp4",
		hidden(props) {
			return props.srcType === "Upload";
		},
	},
	srcFile: {
		type: ControlType4.File,
		title: "File",
		allowedFileTypes: ["mp4", "webm"],
		hidden(props) {
			return props.srcType === "URL";
		},
	},
	playing: {
		type: ControlType4.Boolean,
		title: "Playing",
		enabledTitle: "Yes",
		disabledTitle: "No",
	},
	...borderRadiusControl,
	posterEnabled: {
		type: ControlType4.Boolean,
		title: "Poster",
		enabledTitle: "Yes",
		disabledTitle: "No",
	},
	poster: {
		type: ControlType4.Image,
		title: "Image",
		hidden: ({ posterEnabled }) => !posterEnabled,
		description:
			"We recommend adding a poster. [Learn more](https://www.framer.com/help/articles/how-are-videos-optimized-in-framer/).",
	},
	backgroundColor: {
		type: ControlType4.Color,
		title: "Background",
		defaultValue: "rgba(0,0,0,0)",
	},
	startTime: {
		title: "Start Time",
		type: ControlType4.Number,
		min: 0,
		max: 100,
		step: 0.1,
		unit: "%",
	},
	loop: {
		type: ControlType4.Boolean,
		title: "Loop",
		enabledTitle: "Yes",
		disabledTitle: "No",
	},
	objectFit: {
		type: ControlType4.Enum,
		title: "Fit",
		options: objectFitOptions,
		optionTitles: objectFitOptions.map(titleCase),
	},
	// restartOnEnter: {
	//     type: ControlType.Boolean,
	//     title: "On ReEnter",
	//     enabledTitle: "Restart",
	//     disabledTitle: "Resume",
	// },
	controls: {
		type: ControlType4.Boolean,
		title: "Controls",
		enabledTitle: "Show",
		disabledTitle: "Hide",
		defaultValue: false,
	},
	muted: {
		type: ControlType4.Boolean,
		title: "Muted",
		enabledTitle: "Yes",
		disabledTitle: "No",
	},
	volume: {
		type: ControlType4.Number,
		max: 100,
		min: 0,
		unit: "%",
		hidden: ({ muted }) => muted,
		defaultValue: 25,
	},
	onEnd: {
		type: ControlType4.EventHandler,
	},
	onSeeked: {
		type: ControlType4.EventHandler,
	},
	onPause: {
		type: ControlType4.EventHandler,
	},
	onPlay: {
		type: ControlType4.EventHandler,
	},
	...defaultEvents,
});

// /:https://framerusercontent.com/modules/yDj7wWMyiDppD8RcoPSb/FKDW7WjxmmXbaQHQ5CBY/KhMFb9C09.js
var VideoFonts = getFonts(Video);
var cycleOrder = ["mKqyZfrHy", "YhdhamxZ6", "LSerZejKO"];
var serializationHash = "framer-leiUO";
var variantClassNames = {
	LSerZejKO: "framer-v-8jtifn",
	mKqyZfrHy: "framer-v-9ok121",
	YhdhamxZ6: "framer-v-1kc1vj6",
};
function addPropertyOverrides(overrides, ...variants) {
	const nextOverrides = {};
	variants?.forEach(
		(variant) => variant && Object.assign(nextOverrides, overrides[variant]),
	);
	return nextOverrides;
}
var transition1 = {
	bounce: 0.2,
	delay: 0,
	duration: 0.4,
	type: "spring",
};
var Transition = ({ value, children }) => {
	const config = React3.useContext(MotionConfigContext);
	const transition = value ?? config.transition;
	const contextValue = React3.useMemo(
		() => ({
			...config,
			transition,
		}),
		[JSON.stringify(transition)],
	);
	return (
		<MotionConfigContext.Provider value={contextValue}>
			{children}
		</MotionConfigContext.Provider>
	);
};
var Variants = motion.create(React3.Fragment);
var humanReadableVariantMap = {
	"Stop Play": "LSerZejKO",
	Default: "mKqyZfrHy",
	Mobile: "YhdhamxZ6",
};
var getProps2 = ({ height, id, playing, startTime, width, ...props }) => {
	return {
		...props,
		variant:
			humanReadableVariantMap[props.variant] ?? props.variant ?? "mKqyZfrHy",
		XCkNQEhjr: playing ?? props.XCkNQEhjr ?? true,
		YeZ9uYl7Y: startTime ?? props.YeZ9uYl7Y,
	};
};
var createLayoutDependency = (props, variants) => {
	if (props.layoutDependency)
		return variants.join("-") + props.layoutDependency;
	return variants.join("-");
};
var Component = /* @__PURE__ */ React3.forwardRef(function (props, ref) {
	const { activeLocale, setLocale } = useLocaleInfo();
	const {
		style,
		className,
		layoutId,
		variant,
		XCkNQEhjr,
		YeZ9uYl7Y,
		...restProps
	} = getProps2(props);
	const {
		baseVariant,
		classNames,
		clearLoadingGesture,
		gestureHandlers,
		gestureVariant,
		isLoading,
		setGestureState,
		setVariant,
		variants,
	} = useVariantState({
		cycleOrder,
		defaultVariant: "mKqyZfrHy",
		variant,
		variantClassNames,
	});
	const layoutDependency = createLayoutDependency(props, variants);
	const sharedStyleClassNames = [];
	const scopingClassNames = cx(serializationHash, ...sharedStyleClassNames);
	const ref1 = React3.useRef(null);
	const defaultLayoutId = React3.useId();
	const componentViewport = useComponentViewport();
	return (
		<LayoutGroup id={layoutId ?? defaultLayoutId}>
			<Variants animate={variants} initial={false}>
				<Transition value={transition1}>
					<motion.div
						{...restProps}
						{...gestureHandlers}
						className={cx(
							scopingClassNames,
							"framer-9ok121",
							className,
							classNames,
						)}
						data-framer-name={"Default"}
						layoutDependency={layoutDependency}
						layoutId={"mKqyZfrHy"}
						ref={ref ?? ref1}
						style={{
							backgroundColor:
								"var(--token-dcb5abee-f4cc-4336-9800-a1eb8a5b9414, rgb(21, 21, 19))",
							...style,
						}}
						{...addPropertyOverrides(
							{
								LSerZejKO: {
									"data-framer-name": "Stop Play",
								},
								YhdhamxZ6: {
									"data-framer-name": "Mobile",
								},
							},
							baseVariant,
							gestureVariant,
						)}
					>
						<ComponentViewportProvider>
							<motion.div
								className={"framer-44xpo1-container"}
								layoutDependency={layoutDependency}
								layoutId={"K0AFwRDGQ-container"}
								style={{
									rotate: 27,
									scale: 1.2,
								}}
								variants={{
									YhdhamxZ6: {
										rotate: 33,
									},
								}}
							>
								<Video
									backgroundColor={
										"var(--token-7393ce13-c09e-45e1-9c23-2264be9919ea, rgba(247, 247, 242, 0))"
									}
									borderRadius={0}
									bottomLeftRadius={0}
									bottomRightRadius={0}
									controls={false}
									height={"100%"}
									id={"K0AFwRDGQ"}
									isMixedBorderRadius={false}
									layoutId={"K0AFwRDGQ"}
									loop={true}
									muted={true}
									objectFit={"fill"}
									playing={XCkNQEhjr}
									posterEnabled={false}
									srcFile={
										"https://framerusercontent.com/assets/cPKRRKuW0jpaC4klxDzwXI0sU.mp4"
									}
									srcType={"Upload"}
									srcUrl={
										"https://framerusercontent.com/assets/MLWPbW1dUQawJLhhun3dBwpgJak.mp4"
									}
									startTime={YeZ9uYl7Y}
									style={{
										height: "100%",
										width: "100%",
									}}
									topLeftRadius={0}
									topRightRadius={0}
									volume={25}
									width={"100%"}
									{...addPropertyOverrides(
										{
											LSerZejKO: {
												loop: false,
												playing: false,
											},
											YhdhamxZ6: {
												objectFit: "contain",
											},
										},
										baseVariant,
										gestureVariant,
									)}
								/>
							</motion.div>
						</ComponentViewportProvider>
					</motion.div>
				</Transition>
			</Variants>
		</LayoutGroup>
	);
});
var css = [
	"@supports (aspect-ratio: 1) { body { --framer-aspect-ratio-supported: auto; } }",
	".framer-leiUO.framer-1xm2ztc, .framer-leiUO .framer-1xm2ztc { display: block; }",
	".framer-leiUO.framer-9ok121 { align-content: center; align-items: center; display: flex; flex-direction: row; flex-wrap: nowrap; gap: 0px; height: 800px; justify-content: center; overflow: hidden; padding: 0px; position: relative; width: 1200px; }",
	".framer-leiUO .framer-44xpo1-container { flex: none; height: 100%; mix-blend-mode: screen; position: absolute; right: -247px; top: 0px; width: 100%; z-index: 1; }",
	"@supports (background: -webkit-named-image(i)) and (not (font-palette:dark)) { .framer-leiUO.framer-9ok121 { gap: 0px; } .framer-leiUO.framer-9ok121 > * { margin: 0px; margin-left: calc(0px / 2); margin-right: calc(0px / 2); } .framer-leiUO.framer-9ok121 > :first-child { margin-left: 0px; } .framer-leiUO.framer-9ok121 > :last-child { margin-right: 0px; } }",
	".framer-leiUO.framer-v-1kc1vj6.framer-9ok121 { width: 390px; }",
	".framer-leiUO.framer-v-1kc1vj6 .framer-44xpo1-container { order: 0; right: -433px; width: 250%; }",
];
var FramerKhMFb9C09 = withCSS(Component, css, "framer-leiUO");
var stdin_default = FramerKhMFb9C09;
FramerKhMFb9C09.displayName = "BG_LIQUID";
FramerKhMFb9C09.defaultProps = {
	height: 800,
	width: 1200,
};
addPropertyControls2(FramerKhMFb9C09, {
	variant: {
		options: ["mKqyZfrHy", "YhdhamxZ6", "LSerZejKO"],
		optionTitles: ["Default", "Mobile", "Stop Play"],
		title: "Variant",
		type: ControlType5.Enum,
	},
	XCkNQEhjr: {
		defaultValue: true,
		title: "Playing",
		type: ControlType5.Boolean,
	},
	YeZ9uYl7Y: {
		defaultValue: 0,
		max: 100,
		min: 0,
		step: 0.1,
		title: "Start Time",
		type: ControlType5.Number,
	},
});
addFonts(
	FramerKhMFb9C09,
	[
		{
			explicitInter: true,
			fonts: [],
		},
		...VideoFonts,
	],
	{
		supportsExplicitInterCodegen: true,
	},
);

// virtual:bg-liquid
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {
	base: "YhdhamxZ6",
	xl: "mKqyZfrHy",
};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"6d1ac80c6e7bce05cf1e83998b9524564a80e103f40bc586c8c0153e682ec4cd"
			}
			locale={locale}
			locales={locales}
		>
			{jsx(stdin_default, {
				...rest,
			})}
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders BgLiquidFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"6d1ac80c6e7bce05cf1e83998b9524564a80e103f40bc586c8c0153e682ec4cd"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={stdin_default}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, stdin_default);
var bg_liquid_default = ComponentWithRoot;
export { bg_liquid_default as default };
